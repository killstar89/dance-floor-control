<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dance Floor Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #000;
      overflow: hidden;
    }

    #grid {
      display: grid;
      width: 100vw;
      height: 100vh;
    }

    .box {
      width: 100%;
      height: 100%;
      border: 1px solid #111;
      transition: background-color 0.5s ease, transform 0.5s ease;
    }
  </style>
</head>
<body>
  <div id="grid"></div>

  <script>
    const grid = document.getElementById('grid');
    const colors = {
      blue: ['#0044ff', '#0033cc'],
      purple: ['#800080', '#4b0082'],
      red: ['#ff0000', '#990000'],
      green: ['#00ff00', '#008000'],
      pink: ['#ff69b4', '#ff1493'],
      orange: ['#ffa500', '#ff4500'],
      cyan: ['#00ffff', '#00ced1'],
      rainbow: ['#ff0000', '#ffa500', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#ee82ee']
    };

    let activeColor = 'blue';
    let activePattern = 'spiral';
    let power = true;
    let cols, rows;
    let boxes = [];

    const channel = new BroadcastChannel('dancefloor-control');

    function createGrid() {
      grid.innerHTML = '';
      boxes = [];

      const boxSize = 50;
      cols = Math.floor(window.innerWidth / boxSize);
      rows = Math.floor(window.innerHeight / boxSize);

      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const box = document.createElement('div');
          box.className = 'box';
          grid.appendChild(box);
          boxes.push({ element: box, row, col });
        }
      }
    }

    function applyColors() {
      const colorList = colors[activeColor] || ['#000'];
      const midRow = rows / 2;
      const midCol = cols / 2;

      boxes.forEach(({ element, row, col }, i) => {
        const delay = getPatternDelay(row, col, midRow, midCol);
        const color = colorList[(i + row + col) % colorList.length];

        setTimeout(() => {
          element.style.backgroundColor = power ? color : '#000';
        }, delay);
      });
    }

    function getPatternDelay(row, col, midRow, midCol) {
      switch (activePattern) {
        case 'top-to-bottom': return row * 80;
        case 'left-to-right': return col * 80;
        case 'center-out': return Math.hypot(row - midRow, col - midCol) * 70;
        case 'spiral': return (row + col) * 60;
        case 'checkerboard': return ((row + col) % 2) * 200;
        case 'wave': return Math.sin(col / 2) * 300 + row * 40;
        case 'diagonal': return (row + col) * 75;
        case 'random': return Math.random() * 500;
        case 'flash': return 0;
        default: return 0;
      }
    }

    function loop() {
      if (power) applyColors();
      setTimeout(loop, 2500);
    }

    channel.onmessage = ({ data }) => {
      const { type, value } = data;
      if (type === 'color') activeColor = value;
      if (type === 'pattern') activePattern = value;
      if (type === 'start') power = true;
      if (type === 'stop') power = false;
      applyColors();
    };

    window.addEventListener('resize', () => {
      createGrid();
      applyColors();
    });

    window.onload = () => {
      createGrid();
      applyColors();
      loop();
    };
  </script>
</body>
</html>
