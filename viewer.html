<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dance Floor Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background-color: #000;
    }

    #grid {
      display: grid;
      width: 100vw;
      height: 100vh;
    }

    .colorBox {
      width: 100%;
      height: 100%;
      background-color: #800080;
      border: 1px solid black;
      animation: breathe 6s ease-in-out infinite;
      transition: background-color 3s;
    }

    @keyframes breathe {
      0% {
        transform: scale(1);
        filter: brightness(1);
      }
      50% {
        transform: scale(1.05);
        filter: brightness(1.2);
      }
      100% {
        transform: scale(1);
        filter: brightness(1);
      }
    }
  </style>
</head>
<body>
  <div id="grid"></div>

  <script>
    const colors = {
      blue: ['#0074D9', '#001F3F', '#0050A0', '#003366'],
      purple: ['#800080', '#9202ab', '#360140'],
      red: ['#8B0000', '#FF0000', '#AA0000'],
      green: ['#006400', '#00FF00', '#228B22']
    };

    let colorTheme = localStorage.getItem('color') || 'blue';  // Load color theme from localStorage
    let pattern = localStorage.getItem('pattern') || 'spiral';  // Load pattern from localStorage

    const channel = new BroadcastChannel("dancefloor-control");

    channel.onmessage = (event) => {
      const { type, value } = event.data;
      console.log("Received command:", type, value);

      switch (type) {
        case "start":
          startAnimation();
          break;
        case "stop":
          stopAnimation();
          break;
        case "color":
          updateColorTheme(value);
          break;
        case "pattern":
          switchPattern(value);
          break;
      }
    };

    function getRandomColor() {
      const colorsArray = colors[colorTheme] || colors.blue;
      return colorsArray[Math.floor(Math.random() * colorsArray.length)];
    }

    function createGrid() {
      const grid = document.getElementById('grid');
      grid.innerHTML = ''; // Clear previous grid

      const boxSize = 50;
      const cols = Math.floor(window.innerWidth / boxSize);
      const rows = Math.floor(window.innerHeight / boxSize);

      grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const box = document.createElement('div');
          box.className = 'colorBox';
          box.style.backgroundColor = getRandomColor();
          box.style.animationDelay = `${row * 1.2}s`;
          grid.appendChild(box);
        }
      }
    }

    function changeColors() {
      document.querySelectorAll('.colorBox').forEach(box => {
        box.style.backgroundColor = getRandomColor();
      });
    }

    function startAnimation() {
      createGrid();
      setInterval(changeColors, 4000);
    }

    function stopAnimation() {
      clearInterval(changeColors);
    }

    function updateColorTheme(theme) {
      colorTheme = theme;
      localStorage.setItem('color', theme);  // Save to localStorage
      createGrid();  // Refresh grid with new colors
    }

    function switchPattern(newPattern) {
      pattern = newPattern;
      localStorage.setItem('pattern', newPattern);  // Save pattern to localStorage
      console.log("Pattern switched to:", pattern);
      // You can implement logic to switch animation patterns here
    }

    window.onload = createGrid;
    window.addEventListener('resize', createGrid);
  </script>
</body>
</html>
